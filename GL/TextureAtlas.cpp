#include "TextureAtlas.h"
#define ROTATE
// Loads a recrunch-ed .dds.gz file, and populates the Atlas
int TextureAtlas::loadDDSgz(const std::string& path,Atlas& atlas){
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D,*(atlas.m_texture));
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	gzFile gzhandle = gzopen(path.c_str(),"rb");
	uint32_t * header = new uint32_t[32];
	gzread(gzhandle, header, 128);
	if (header[0] != 0x20534444){ // "DDS " as a uint32_t
		delete[] header;
		gzclose(gzhandle);
		return -1;
	}else{
		atlas.height = header[3];
		atlas.width = header[4];
		uint32_t width = atlas.width;
		uint32_t height = atlas.height;
		uint32_t mipmapcount = header[7];
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAX_LEVEL, mipmapcount-1);
		uint32_t fourCC = header[21];
		uint32_t blockSize = 16;
		uint32_t size = ((width + 3)/4)*((height + 3)/4)*blockSize;
		delete[] header;
		switch(fourCC){
			case 0x31545844: // DXT1
				atlas.format = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
				blockSize = 8;
				break;
			case 0x33545844: // DXT3
				atlas.format = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
				break;
			case 0x35545844: // DXT5
				atlas.format = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
				break;
			default:
				return -1;
				break;
		}
		uint8_t *data = new uint8_t[size];
		for (uint32_t level=0;level<mipmapcount;level++){
			gzread(gzhandle,data,size);
			glCompressedTexImage2D(GL_TEXTURE_2D,level,atlas.format,width,height,0,size,data);
			width = std::max(width/2, 1U);
			height = std::max(height/2,1U);
			size = ((width + 3)/4)*((height + 3)/4)*blockSize;
		}
		gzclose(gzhandle);
		delete[] data;
	}
	return 0;
}
// Loads a Crunch Texture Pack (.bin) to populate the atlas table. These files are generated by crunch.
// Returns false if failed to load the file, otherwise returns true.
std::string getString(std::ifstream& input_file){
	std::string value = "";
	char chr = 0;
	do{
		input_file.read(&chr,1);
		if (chr != 0){
			value += chr;
		}
	}while (chr != 0);
	return value;
}
bool TextureAtlas::loadFromFile(const std::string& file_path){
	std::ifstream input_file(file_path, std::ifstream::in | std::ifstream::binary);
	if(!input_file){
		return false;
	}
	std::string path = file_path.substr(0, file_path.find_last_of("\\/") + 1);
	uint16_t num_textures=0,num_images=0;
	input_file.read(reinterpret_cast<char*>(&num_textures),2);
	m_num_textures = num_textures;
	m_texture_handles = new GLuint[m_num_textures];
	glGenTextures(m_num_textures,m_texture_handles);
	for (int textureIndex = 0; textureIndex < num_textures; textureIndex++){
		std::string textureName = getString(input_file);
		input_file.read(reinterpret_cast<char*>(&num_images),2);
		m_atlas_list.emplace_back(Atlas());
		m_atlas_list[textureIndex].m_texture = m_texture_handles + textureIndex;
		loadDDSgz(path + textureName + ".dds.gz",m_atlas_list[textureIndex]);
		for (int imageindex = 0; imageindex < num_images; imageindex++){
			std::string img_name = getString(input_file);
			Rect<uint16_t> tmp;
			input_file.read(reinterpret_cast<char*>(&tmp.left),8);
			float width = static_cast<float>(m_atlas_list[textureIndex].width);
			float height = static_cast<float>(m_atlas_list[textureIndex].height);
			m_atlas_list[textureIndex].m_texture_table[img_name] = Rect<float>(
				static_cast<float>(tmp.left)/width,
				static_cast<float>(tmp.top)/height,
				static_cast<float>(tmp.width)/width,
				static_cast<float>(tmp.height)/height);
#ifdef TRIM
			input_file.seekg(8,ios::cur);
#endif
#ifdef ROTATE
			input_file.read(reinterpret_cast<char*>(&m_atlas_list[textureIndex].rotated),1);
#endif
		}
	}
	input_file.close();
	if(!m_atlas_list.size()){
		return false;
	}
	return true;
}

// Finds a Moony Texture inside the atlas table.
// Returns a valid Texture if found in the TextureAtlas, otherwise returns a null Texture.
const Texture TextureAtlas::findSubTexture(const std::string& name){
	Texture texture;
	for(auto& atlas : m_atlas_list){
		if(atlas.m_texture_table.find(name) != atlas.m_texture_table.end()){
			texture = Texture(atlas.m_texture, atlas.m_texture_table[name]);
			texture.width = texture.m_rect.width * atlas.width;
			texture.height = texture.m_rect.height * atlas.height;
			break;
		}
	}
	return texture;
}

// This function gets a list of all the seperate image names that are in the TextureAtlas.
// Returns a std::vector<std::string> full of filenames corresponding to images in the TextureAtlas.
std::vector<std::string> TextureAtlas::getSubTextureNames(){
	std::vector<std::string> names;
	for(const auto& atlas : m_atlas_list)
	{
		for(const auto& itr : atlas.m_texture_table){
			names.push_back(itr.first);
		}
	}
	return names;
}
