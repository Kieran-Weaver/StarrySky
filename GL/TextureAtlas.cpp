#include "TextureAtlas.h"
#include <iostream>
#define ROTATE
// Loads a recrunch-ed .dds.gz file, and populates the Atlas
TextureAtlas::TextureAtlas(){
	Bitmasks.set_empty_key(std::numeric_limits<GLuint>::max());
}
bool TextureAtlas::loadDDSgz(const std::string& path,Atlas& atlas){
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D,*(atlas.m_texture));
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	gzFile gzhandle = gzopen(path.c_str(),"rb");
	if (!gzhandle){
		return false;
	}
	uint32_t * header = new uint32_t[32];
	if (gzread(gzhandle, header, 128) == -1){
		delete[] header;
		gzclose_r(gzhandle);
		return false;
	}
	if (header[0] != 0x20534444){ // "DDS " as a uint32_t
		delete[] header;
		gzclose_r(gzhandle);
		return false;
	}else{
		atlas.height = header[3];
		atlas.width = header[4];
		uint32_t width = atlas.width;
		uint32_t height = atlas.height;
		uint32_t mipmapcount = header[7];
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAX_LEVEL, mipmapcount-1);
		uint32_t fourCC = header[21];
		uint32_t blockSize = 16;
		uint32_t size = ((width + 3)/4)*((height + 3)/4)*blockSize;
		delete[] header;
		switch(fourCC){
			case 0x31545844: // DXT1
				atlas.format = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
				blockSize = 8;
				break;
			case 0x33545844: // DXT3
				atlas.format = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
				break;
			case 0x35545844: // DXT5
				atlas.format = GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
				break;
			default:
				return false;
				break;
		}
		uint8_t *data = new uint8_t[size];
		for (uint32_t level=0;level<mipmapcount;level++){
			if (gzread(gzhandle,data,size) == -1){
				gzclose_r(gzhandle);
				delete[] data;
				return false;
			}
			glCompressedTexImage2D(GL_TEXTURE_2D,level,atlas.format,width,height,0,size,data);
			width = std::max(width/2, 1U);
			height = std::max(height/2,1U);
			size = ((width + 3)/4)*((height + 3)/4)*blockSize;
		}
		gzclose_r(gzhandle);
		delete[] data;
	}
	return true;
}
bool TextureAtlas::loadBINgz(const std::string& path, const Atlas& atlas){
	Bitmask maskwrapper;
	maskwrapper.mask = boost::dynamic_bitset<>(atlas.width*atlas.height);
	maskwrapper.width = atlas.width;
	maskwrapper.height = atlas.height;
	gzFile gzhandle = gzopen(path.c_str(),"rb");
	if (!gzhandle){
		return false;
	}
	boost::dynamic_bitset<>::block_type *data = new boost::dynamic_bitset<>::block_type[atlas.width*atlas.height/(8*sizeof(boost::dynamic_bitset<>::block_type))];
	if (gzread(gzhandle,data,atlas.width*atlas.height/8) == -1){
		delete[] data;
		gzclose_r(gzhandle);
		return false;
	}
	gzclose_r(gzhandle);
	boost::from_block_range(data,data+atlas.width*atlas.height/(8*sizeof(boost::dynamic_bitset<>::block_type)),maskwrapper.mask);
	Bitmasks.insert(std::make_pair(*atlas.m_texture,maskwrapper));
	delete[] data;
	return true;
}
// Loads a Crunch Texture Pack (.bin) to populate the atlas table. These files are generated by crunch.
// Returns false if failed to load the file, otherwise returns true.
std::string getString(std::ifstream& input_file){
	std::string value = "";
	char chr = 0;
	do{
		input_file.read(&chr,1);
		if (chr != 0){
			value += chr;
		}
	}while (chr != 0);
	return value;
}
bool TextureAtlas::loadFromFile(const std::string& file_path){
	std::ifstream input_file(file_path, std::ifstream::in | std::ifstream::binary);
	if(!input_file){
		return false;
	}
	std::string path = file_path.substr(0, file_path.find_last_of("\\/") + 1);
	uint16_t num_textures=0,num_images=0;
	input_file.read(reinterpret_cast<char*>(&num_textures),2);
	m_num_textures = num_textures;
	m_texture_handles = new GLuint[m_num_textures];
	glGenTextures(m_num_textures,m_texture_handles);
	for (int textureIndex = 0; textureIndex < num_textures; textureIndex++){
		std::string textureName = getString(input_file);
		input_file.read(reinterpret_cast<char*>(&num_images),2);
		m_atlas_list.emplace_back(Atlas());
		m_atlas_list[textureIndex].m_texture = m_texture_handles + textureIndex;
		if (!loadDDSgz(path + textureName + ".dds.gz",m_atlas_list[textureIndex])){
			return false;
		}
		if (!loadBINgz(path + textureName + ".bin.gz",m_atlas_list[textureIndex])){
			return false;
		}
		for (int imageindex = 0; imageindex < num_images; imageindex++){
			std::string img_name = getString(input_file);
			Rect<uint16_t> tmp;
			input_file.read(reinterpret_cast<char*>(&tmp.left),8);
			float width = static_cast<float>(m_atlas_list[textureIndex].width);
			float height = static_cast<float>(m_atlas_list[textureIndex].height);
			m_atlas_list[textureIndex].m_texture_table[img_name].m_rect = Rect<float>(
				static_cast<float>(tmp.left)/width,
				static_cast<float>(tmp.top)/height,
				static_cast<float>(tmp.width)/width,
				static_cast<float>(tmp.height)/height);
			m_atlas_list[textureIndex].m_texture_table[img_name].width = tmp.width;
			m_atlas_list[textureIndex].m_texture_table[img_name].height = tmp.height;
#ifdef TRIM
			input_file.seekg(8,ios::cur);
#endif
#ifdef ROTATE
			input_file.read(reinterpret_cast<char*>(&m_atlas_list[textureIndex].m_texture_table[img_name].rotated),1);
			if (m_atlas_list[textureIndex].m_texture_table[img_name].rotated){
				m_atlas_list[textureIndex].m_texture_table[img_name].m_rect = Rect<float>(
				static_cast<float>(tmp.left)/width,
				static_cast<float>(tmp.top)/height,
				static_cast<float>(tmp.height)/width,
				static_cast<float>(tmp.width)/height);
			}
#endif
		}
	}
	input_file.close();
	if(!m_atlas_list.size()){
		return false;
	}
	return true;
}

// Finds a Moony Texture inside the atlas table.
// Returns a valid Texture if found in the TextureAtlas, otherwise returns a null Texture.
const Texture TextureAtlas::findSubTexture(const std::string& name){
	Texture texture;
	for(auto& atlas : m_atlas_list){
		if(atlas.m_texture_table.find(name) != atlas.m_texture_table.end()){
			texture = Texture(atlas.m_texture, atlas.m_texture_table[name].m_rect);
			texture.width = atlas.m_texture_table[name].width;
			texture.height = atlas.m_texture_table[name].height;
			texture.rotated = atlas.m_texture_table[name].rotated;
			break;
		}
	}
	return texture;
}

// This function gets a list of all the seperate image names that are in the TextureAtlas.
// Returns a std::vector<std::string> full of filenames corresponding to images in the TextureAtlas.
std::vector<std::string> TextureAtlas::getSubTextureNames(){
	std::vector<std::string> names;
	for(const auto& atlas : m_atlas_list)
	{
		for(const auto& itr : atlas.m_texture_table){
			names.push_back(itr.first);
		}
	}
	return names;
}

bool TextureAtlas::PixelPerfectTest(const Sprite& Object1, const Sprite& Object2){
	Rect<float> Intersection; 
	const Rect<float> o1globalbounds = Object1.getAABB();
	const Rect<float> o2globalbounds = Object2.getAABB();
	if (o1globalbounds.RIntersects(o2globalbounds, Intersection)) {
		auto& mask1 = Bitmasks[*Object1.m_subtexture.m_texture];
		auto& mask2 = Bitmasks[*Object2.m_subtexture.m_texture];
		// Loop through our pixels
		glm::mat4 o1t = glm::inverse(Object1.m_model);
		glm::mat4 o2t = glm::inverse(Object2.m_model);
		glm::mat4x2 o1t_subrect_to_pixel(
			Object1.m_subtexture.width,0,
			0,Object1.m_subtexture.height,
			0,0,
			Object1.m_subtexture.m_rect.left*mask1.width,Object1.m_subtexture.m_rect.top*mask1.height);
		glm::mat4x2 o2t_subrect_to_pixel(
			Object2.m_subtexture.width,0,
			0,Object2.m_subtexture.height,
			0,0,
			Object2.m_subtexture.m_rect.left*mask2.width,Object2.m_subtexture.m_rect.top*mask2.height);
		for (int i = static_cast<int>(Intersection.left); i < static_cast<int>(Intersection.left+Intersection.width); i++) {
			for (int j = static_cast<int>(Intersection.top); j < static_cast<int>(Intersection.top+Intersection.height); j++) {

				glm::vec4 o1v = o1t*glm::vec4(i-Object1.center.x, j-Object1.center.y,0.f,1.f);
				glm::vec4 o2v = o2t*glm::vec4(i-Object2.center.x, j-Object2.center.y,0.f,1.f);

			// Make sure pixels fall within the sprite's subrect
				if (o1v.x > 0.f && o1v.y > 0.f && o2v.x > 0.f && o2v.y > 0.f &&
					o1v.x < 1.f && o1v.y < 1.f && o2v.x < 1.f && o2v.y < 1.f) {
					glm::ivec2 pixel1 = o1t_subrect_to_pixel * o1v;
					glm::ivec2 pixel2 = o2t_subrect_to_pixel * o2v;
					if (mask1.mask[pixel1.x+pixel1.y*mask1.width] && mask2.mask[pixel2.x+pixel2.y*mask2.width]){
						return true;
					}
				}
			}
		}
	}
	return false;
}
