#include "TextureAtlas.h"
#define TRIM
#define ROTATE
static uint16_t getUint16_t(const uint8_t *data, int pos){
	return data[pos] + (static_cast<uint16_t>(data[pos+1])<<8);
}
static std::string getString(const uint8_t *data,int start, int length){
	int end=start;
	const char* chardata = reinterpret_cast<const char*>(data);
	while (end<length && (chardata[end] != 0)){
		end++;
	}
	return std::string(chardata+start,end-start);
}
// Loads a recrunch-ed .dds.gz file, and populates the Atlas
int TextureAtlas::loadDDSgz(const std::string& path,Atlas& atlas){
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D,*(atlas.m_texture));
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	gzFile gzhandle = gzopen(path.c_str(),"rb");
	char * header = new char[129];
	gzread(gzhandle, header, 128);
	header[128] = '\0';
	if (strncmp(header,"DDS ",4)!=0){
		delete[] header;
		gzclose(gzhandle);
		return -1;
	}else{
		atlas.height = *reinterpret_cast<uint32_t*>(header+12);
		atlas.width = *reinterpret_cast<uint32_t*>(header+16);
		uint32_t width = atlas.width;
		uint32_t height = atlas.height;
		uint32_t mipmapcount = *reinterpret_cast<uint32_t*>(header+28);
		uint32_t fourCC = *reinterpret_cast<uint32_t*>(header+84);
		uint32_t blockSize = 16;
		uint32_t size = ((width + 3)/4)*((height + 3)/4)*blockSize;
		delete[] header;
		switch(fourCC){
			case 0x31545844: // DXT1
				atlas.format = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
				blockSize = 8;
				break;
			case 0x33545844: // DXT3
				atlas.format = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;
				break;
			case 0x35545844: // DXT5
				atlas.format = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
				break;
			default:
				return -1;
				break;
		}
		uint8_t *data = new uint8_t[size];
		for (uint32_t level=0;level<mipmapcount;level++){
			gzread(gzhandle,data,size);
			glCompressedTexImage2D(GL_TEXTURE_2D,level,atlas.format,width,height,0,size,data);
			width = std::max(width/2, 1U);
			height = std::max(height/2,1U);
			size = ((width + 3)/4)*((height + 3)/4)*blockSize;
		}
		gzclose(gzhandle);
		delete[] data;
	}
	return 0;
}
// Loads a Crunch Texture Pack (.bin) to populate the atlas table. These files are generated by crunch.
// Returns false if failed to load the file, otherwise returns true.
bool TextureAtlas::loadFromFile(const std::string& file_path){
	std::ifstream input_file(file_path, std::ifstream::in | std::ifstream::binary);
	if(!input_file){
		return false;
	}
	std::string path = file_path.substr(0, file_path.find_last_of("\\/") + 1);
	uint16_t num_textures=0,num_images=0;
	int pos=2;
	input_file.seekg(0,input_file.end);
	int length = input_file.tellg();
	input_file.seekg(0,input_file.beg);
	uint8_t * data = new uint8_t[length];
	input_file.read(reinterpret_cast<char*>(data),length);
	num_textures = getUint16_t(data,0);
	m_num_textures = num_textures;
	m_texture_handles = new GLuint[m_num_textures];
	glGenTextures(m_num_textures,m_texture_handles);
	for (int textureIndex = 0; textureIndex < num_textures; textureIndex++){
		std::string textureName = getString(data,pos,length);
		pos += textureName.size() + 1;
		num_images = getUint16_t(data,pos);
		pos += 2;
		m_atlas_list.emplace_back(Atlas());
		m_atlas_list[textureIndex].m_texture = m_texture_handles + textureIndex;
		loadDDSgz(textureName + ".dds.gz",m_atlas_list[textureIndex]);
		for (int imageindex = 0; imageindex < num_images; imageindex++){
			std::string img_name = getString(data,pos,length);
			pos += img_name.size() + 1;
#ifdef TRIM
			pos += 8;
#endif
			Rect<uint16_t> tmp;
			tmp.left = getUint16_t(data,pos);
			pos += 2;
			tmp.top = getUint16_t(data,pos);
			pos += 2;
			tmp.width = getUint16_t(data,pos);
			pos += 2;
			tmp.height = getUint16_t(data,pos);
			pos += 2;
			float width = static_cast<float>(m_atlas_list[textureIndex].width);
			float height = static_cast<float>(m_atlas_list[textureIndex].height);
			m_atlas_list[textureIndex].m_texture_table[img_name] = Rect<float>(
				static_cast<float>(tmp.left)/width,
				static_cast<float>(tmp.top)/height,
				static_cast<float>(tmp.width)/width,
				static_cast<float>(tmp.height)/height);
#ifdef ROTATE
			pos++;
#endif
		}
	}
	delete[] data;
	input_file.close();
	if(!m_atlas_list.size()){
		return false;
	}
	return true;
}

// Finds a Moony Texture inside the atlas table.
// Returns a valid Texture if found in the TextureAtlas, otherwise returns a null Texture.
const Texture TextureAtlas::findSubTexture(const std::string& name){
	Texture texture;
	for(auto& atlas : m_atlas_list){
		if(atlas.m_texture_table.find(name) != atlas.m_texture_table.end()){
			texture = Texture(atlas.m_texture, atlas.m_texture_table[name]);
			break;
		}
	}
	return texture;
}

// This function gets a list of all the seperate image names that are in the TextureAtlas.
// Returns a std::vector<std::string> full of filenames corresponding to images in the TextureAtlas.
std::vector<std::string> TextureAtlas::getSubTextureNames(){
	std::vector<std::string> names;
	for(const auto& atlas : m_atlas_list)
	{
		for(const auto& itr : atlas.m_texture_table){
			names.push_back(itr.first);
		}
	}
	return names;
}
